name: ci

on:
  push:
  pull_request:
  schedule:
    - cron: "0 0 * * SUN"

jobs:
  build:
    # We want to run on external PRs, but not on our own internal PRs as
    # they'll be run by the push to the branch.
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name != github.repository
    strategy:
      fail-fast: false # Let the workflow continue as much as possible
      matrix:
        include:
          - os: windows-latest
            lisp: sbcl-bin/2.1.10
            destination: cg.exe
          - os: ubuntu-latest
            lisp: sbcl-bi/2.1.10
            destination: cg-linux
          - os: macos-latest
            lisp: sbcl-bi/2.1.10
            destination: cg-osx
    defaults:
      run:
        shell: lispsh {0}
    name: build with ${{ matrix.lisp }} on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    steps:
      - uses: 40ants/setup-lisp@v2
        if: github.event_name != 'schedule'
        with:
          roswell-version: v21.10.14.111
          asdf-version: 3.3.5.3
          qlot-version: 0.11.5
        env:
          LISP: ${{ matrix.lisp }}
      - uses: 40ants/setup-lisp@v2
        if: github.event_name == 'schedule'
        with:
          roswell-version: latest
          asdf-version: 3.3.5.3 # latest is currently broken https://github.com/roswell/roswell/issues/497
          qlot-version: latest
        env:
          LISP: sbcl-bin
      - name: Set up caching for roswell files
        id: cache-dot-roswell
        uses: actions/cache@v1
        with:
          path: ~/.roswell
          key: ${{ runner.os }}-dot-roswell-${{ matrix.lisp }}-${{ hashFiles('**/*.asd') }}
          restore-keys: |
            ${{ runner.os }}-dot-roswell-${{ matrix.lisp }}-
            ${{ runner.os }}-dot-roswell-
      - uses: actions/checkout@v2
        with:
          # By default, this action would fetch a single commit only;
          # however, we are counting the number of commits since the "last tag"
          # inside build.lisp, and in order for that to work we have to figure
          # out a way to fetch all the ancestors of the current commit until we
          # land on the target tag...or we fetch all the history.
          #
          # Fetching the complete history will do just fine.
          fetch-depth: 0
      - name: Build the binary
        run: |
          make binary-ros
          mv bin/cg bin/${{ matrix.destination }}
      - name: Test loading of custom .cgrc
        run: |
          bin/${{ matrix.destination }} --version

          cat <<EOF > ~/.cgrc
          (cg:define-guesser echo
              ("(.+)" (cmd))
            (format NIL "~a" cmd))
          EOF
          bin/${{ matrix.destination }} --debug | grep ECHO
      - name: Upload the binary
        uses: actions/upload-artifact@v2
        with:
          name: binaries
          path: bin/${{ matrix.destination }}
  release:
    if: startsWith(github.ref, 'refs/tags/')
    needs: [build]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/download-artifact@v2
        with:
          name: binaries
          path: bin/
      - name: Extract release notes
        id: extract-release-notes
        uses: ffurrer2/extract-release-notes@v1
      - name: Create release
        uses: softprops/action-gh-release@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          draft: false
          prerelease: false
          tag_name: ${{ github.ref }}
          name: ${{ github.ref }}
          body: ${{ steps.extract-release-notes.outputs.release_notes }}
          files: bin/*
